## n+1 카드뽑기 문제
n+1 카드뽑기 문제는 1부터 n까지의 숫자가 적힌 카드들 중에서 두 숫자를 더해 n+1이 되는 경우가 있을 때, 해당 라운드가 증가하는 상황을 해결하는 문제다. 

해당 문제는 HashSet을 활용하여 라운드별로 빠르게 값을 체크하고 지움으로써 문제를 해결하였다.

이 과정에서 Set의 특성에 대해서 조금 더 자세한 정보가 궁금하였고, 가볍게 개념과 Set의 종류들을 정리 해보려고 한다.

<br>

## 1. Set이란?
`Set`은 중복된 요소를 허용하지 않고, 순서를 유지하지 않는 컬렉션이다. 이 특성 덕분에 특정 요소의 존재 여부를 확인하거나 중복된 데이터를 제거하는 데 매우 유용하다. 

주요 특징으로는 내부적으로 **해시 테이블** 또는 **트리** 구조를 사용하여 요소를 관리하며, 요소 간의 순서를 유지하지 않는다는 점이다.

**메서드:**
- `add(E e)`: 지정된 요소를 `Set`에 추가한다. 이미 존재하는 경우에는 추가하지 않는다.
- `addAll(Collection<? extends E> c)`: 지정된 컬렉션의 모든 요소를 `Set`에 추가한다.
- `clear()`: `Set`의 모든 요소를 제거한다.
- `contains(Object o)`: 지정된 요소가 `Set`에 포함되어 있는지 확인한다.
- `isEmpty()`: `Set`이 비어있는지 확인한다.
- `size()`: `Set`의 요소 수를 반환한다.
- `remove(Object o)`: 지정된 요소를 `Set`에서 제거한다.

**Set의 알고리즘 특성**
- **존재 여부 확인:** 특정 요소가 존재하는지 빠르게 확인할 때 `Set`을 사용하면 `O(1)` 시간 복잡도로 확인할 수 있다.
- **중복 제거:** 배열이나 리스트에서 중복된 값을 제거할 때 `Set`을 사용하면 효율적이다.

<br>

### 2. 다른 Set 구현체

### HashSet
- **중복 제거:** `HashSet`은 중복된 요소를 허용하지 않으며, 요소의 추가, 삭제, 탐색이 빠르다. 이는 해시 테이블을 기반으로 하고 있기 때문이다.
- **순서 무관:** `HashSet`은 요소의 삽입 순서를 유지하지 않으며, 순서에 상관없이 요소들을 관리한다.
- **빠른 탐색 속도:** `HashSet`은 요소를 `O(1)` 시간 복잡도로 탐색할 수 있어, 대량의 데이터에서 특정 값을 빠르게 찾을 수 있다.

### TreeSet
- **정렬된 데이터 관리:** `TreeSet`은 요소들을 자동으로 정렬된 상태로 유지한다. 내부적으로 **이진 탐색 트리**(특히 레드-블랙 트리)를 사용하여 정렬된 순서로 데이터를 관리한다.
- **시간 복잡도:** 삽입, 삭제, 탐색의 시간 복잡도가 `O(log n)`이므로, 정렬이 필요한 경우 적합하다.
- **범위 쿼리:** 정렬된 데이터를 관리하기 때문에, 특정 범위의 데이터를 검색하는 작업이 효율적이다.

### LinkedHashSet
- **삽입 순서 유지:** `LinkedHashSet`은 요소가 삽입된 순서를 유지한다. 이는 **이중 연결 리스트** 구조를 사용하여 삽입된 순서를 보존하기 때문이다.
- **메모리 사용:** `LinkedHashSet`은 삽입 순서를 유지하는 데 추가적인 메모리가 필요하며, `HashSet`보다 다소 성능이 떨어질 수 있다.
- **빠른 탐색:** `LinkedHashSet`도 `HashSet`처럼 해시 테이블을 기반으로 하여 `O(1)` 시간 복잡도로 요소를 탐색할 수 있지만, 순서를 유지하는 오버헤드가 추가된다.

<br>

## 3. 최적의  Set 선택
| **속성**                     | **HashSet**                                            | **LinkedHashSet**                                              |
|------------------------------|--------------------------------------------------------|----------------------------------------------------------------|
| **데이터 구조**               | 해시테이블을 사용하여 요소 저장                        | 해시테이블과 이중 연결 리스트를 사용하여 요소 저장             |
| **삽입 순서 보장**            | 보장 안 됨                                             | 삽입 순서 보장                                                 |
| **Null 요소 허용**            | 하나의 `null` 요소 허용                               | 하나의 `null` 요소 허용                                        |
| **메모리 사용량**             | 메모리 사용 적음                                      | 메모리 사용 많음                                               |
| **성능**                      | 빠름                                                   | 다소 느림                                                     |
| **동기화**                    | 비동기화                                               | 비동기화                                                      |
| **삽입, 삭제, 검색 복잡도**   | `O(1)`                                                | `O(1)`                                                        |
| **사용 시점**                 | 순서가 중요하지 않은 경우 유용                         | 순서가 중요할 때 유용                                          |

**알고리즘에서의 활용 예시:**
- **`HashSet`** : 순서가 중요하지 않고, 빠른 검색이 필요한 경우 `HashSet`이 가장 적합하다. 카드뽑기 문제처럼 특정 값의 존재 여부만 확인하는 알고리즘에서 사용된다.
- **`LinkedHashSet`** : 데이터의 삽입 순서가 중요하며, 중복 제거와 순서 보장이 동시에 필요할 때 유용하다. 중복을 제거한 후 순서대로 데이터를 출력하는 문제에서 `LinkedHashSet`이 적합하다.

<br>
<br>

> docs : [Java Set Documentation](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html)
